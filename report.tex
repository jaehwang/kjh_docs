\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{listings}
\input{macro.tex}

\usepackage{fullpage}
\usepackage{kotex}

\usepackage[onehalfspacing]{setspace}

\usepackage{ifpdf} 
\ifpdf
    \usepackage[unicode]{hyperref}
    \input glyphtounicode\pdfgentounicode=1 
\else
    \usepackage[unicode,dvipdfm]{hyperref} 
\fi

\usepackage{pgf}

\title{QCon San Francisco 2010}
\author{김재황 \\ 소프트웨어센터}

\begin{document}

\maketitle

\section{개요}

QCon은 직업적으로 software professional들이 관심을 가질만한 
다양한 주제들 한 자리에 모아 놓은 컨퍼런스라고 할 수 있다. 11월 1일부터 5일까지
샌프란시스코에서 열렸던 QCon의 프로그램도 Agile, Java, NoSQL, REST, 
개발과 운영, architecture, cloud, 보안, parallel programming
등의 내용으로 채워져 있었다. 

\begin{itemize}
\item Tutorial
    \begin{itemize}
    \item REST from Scratch
    \item Continuous Delivery
    \item  Clarity Rules: Six Collaboration Skills for Effective, Successful Teams
    \item Rulemakers and Toolmakers: Adaptive Object Models as Agile Division of Labor
    \item Resource-Oriented Architectures: Information First
    \item Secrets of Agile Architecture
    \item Individual and Team Dynamics: Fundamental Skills Needed to Deliver on the Promise of Lean and Agile
    \end{itemize}
\item Conference Track
    \begin{itemize}
    \item Agile Evolution
    \item Architectures You've Always Wondered About
    \item Dev and Ops: A Single Team
    \item Java, the Platform
    \item Architecture Anarchists
    \item Learning from Experience
    \item NoSQL
    \item Securing the Web: Capabilities, JavaScript, and HTML
    \item Design at Scale
    \item Intuitive Parallel Programming
    \item Real Life Cloud Architectures
    \item SOA for the REST of Us
    \end{itemize}
\end{itemize}

컨퍼런스 웹사이트 \url{http://qconsf.com/sf2010/}에서 좀 더 자세한 내용이나 slide 파일을 얻을 수 있다.

% \begin{figure}[t]
%     \begin{Frame}
%         \begin{center}
%         \pgfimage[width=.8\textwidth,page=1]{slide-qcon}
%         \end{center}
%     \end{Frame}
%     \caption{QCon 2010}
%     \label{qcon}
% \end{figure}

%TODO: 두 세션에 대해 뭐라고 한 마디 해야지...

\subsection{Forty Years of Fun with Computers}

Ending Keynote 11/3. Smalltalk 동네에서 유명한 Dan Ingalls의 무대.
최근에는 Lively Kernel프로젝트를 하신다니 놀라울 따름이다.
관록이 엄청 발산되는 무대였다.
 
맥에서 Squeak Smalltalk이라는 걸 이용해 자신이 처음 만든 포트란 코드도
보여주시고, 재미있는 Smalltalk프로그램도 직접 실행을 해 주시고,
Lively도 시연을 해주셨다.
 
Presentation도 Squeak에서 실행되는, 나로서는 알수 없는 프로그램으로 했다.

\subsection{San Francisco Giants의 월드 시리즈 우승 기념 행진}

11월 1일에 샌프란시스코 자이언츠가 월드 시리즈 챔피언 자리에
56년만에 오르는 일이 생겼다. 빡빡한 일정으로 샌프란시스코 구경도 제대로
못하고 돌아갈 걸로 생각했는데 완전 대박이다. 

11월 3일에는 챔피언 퍼레이드가 열렸다. 컨퍼런스 오전  스케줄이 조정이 
되어 퍼레이드를 볼 수 있는 40분의 시간이 주어졌다.  
퍼레이드는 Market street를 지나갔는데 QCon이 진행되고 있는
Westin호텔이 바로 그 길에 있다. 
거리는 아침부터 인파로 가득찬 상태이지만 나도 (Lotte) Giants 팬인데 안
나갈 수 없었다.
앞사람 머리만 실컷 보고 말았지만 잠시나마 Giants의 팬으로서 이곳
사람들과 기쁨을 공유했던 일은 Lotte Giants가 우승하기 전까지는 잊지
못할 것 같다.
 
\section{Culture}

\subsection{Innovation at Google}
Opening Keynote 11/3. Google의 Patrick Copeland의 키노트.

Pretotyping\nocite{pretotype}이라는 개념을 설명했다.
Prototyping이 ``이걸 만들 수 있나?''에 대한 답을 찾는 
것이라면, pretotyping은 ``사람들이 이것을 좋아할까?''에 대한 답을 찾는 
것이라고 한다.
제대로 만들 수 있나를 고민하기 앞서 필요한 지를 따져봐야 한다는 점을 
강조했다.

\begin{quote}
``Build the right `it' before you build `it' right.''
\end{quote}

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-pretotype}
        \end{center}
    \end{Frame}
    \caption{Innovation at Google}
    \label{pretotyping}
\end{figure}

이노베이션은 아이디어가 아니라 사람(innovator)에 의해서 일어나는 것이라고 한다. 
에디슨의 ``천재는 1\%의 영감과 99\%의 땀으로 만들어진다''는 말을
인용했는데 매우 공감이 갔다. 실제로 해봐야만 좋은 아이디어인지 아닌지 
알 수 있다는 뜻으로 생각했다.

% \subsection{Conference 11/3 The Role of Hypermedia and the Future of
%   Web Integration}
%  
% 하루종일 했던 튜토리얼을 한 시간으로 압축한 것에 지나지 않음. 다른 데
% 들어갈 걸 ㅠㅠ.
%  
% 튜토리얼에서 언급하지 않았던 키워드들:
% \begin{itemize}
% \item mikyung: rule engine in Resfulie. 클라이언트를 좀 쉽게 만들 수
%   있도록 한 DSL인듯.
%   \begin{itemize}
%   \item 부인이 한국인이라더니 부인 이름이 미경인듯. 기회가 있으면 한 번
%     물어 봐야지.
%   \end{itemize}
% \item client++, JSONP, code on demand
% \item atom, xhtml, websocket, opensearch, ...
%   \begin{itemize}
%   \item 튜토리얼 때 조금 설명한 것들도 있지만 오늘 시간이 없는
%     와중에는는 언급만 하더군.
%   \end{itemize}
% \end{itemize}
 
\subsection{Keeping Agile Agile}

Conference 11/3. Dan North의 발표. 

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-agile-agile}
        \end{center}
    \end{Frame}
    \caption{Keep Agile Agiel}
    \label{agile agile}
\end{figure}

매 발표가 끝날 때 마다 초록/노랑/빨강 종이를 한 장씩 항아리에 넣어
발표에 대한 평가를 한다.  이날 내가 참석한 다른 발표는 다 초록을
넣었는데 이 발표만 노랑을 넣었다.  내용이 없어서. 농담 따먹기는 엄청했다. 
문서를 안 쓰기 시작하면 Agile을 시작하는 거라는 등의 별로 재미 없는 농담.

그래도 조금 정리하자면 fear를 다스리지 못하면 gantt chart라는 재앙(ㅠㅠ)이 
온다는 얘기다. 재앙을 막기 위해 Agile 방법론이 필요하단다.

\begin{center}
Fear $\rightarrow$ Risk $\rightarrow$ Process $\rightarrow$ Hate(meetings, gantt chart, ...)
\end{center}

Agile 방법론에서 이야기하는 BP라는 것도 조심해서 활용해야 한단다. 
조직의 expert에게는 BP가 오히려 장애물이 될 수 있기 때문이라고 한다.

% BP는 조직의 expert나 proficient level의 사람들 발목을 잡을 수도 있다.
% 따라서 BP는 prescriptive 한 것 보다는 descriptive한 것이 좋다는 얘기를
% 하고자 한듯.

인터넷을 좀 검색하니 이 talk의 주요 내용을 다룬 
기사\footnote{\url{http://www.infoq.com/articles/better-best-practices}}가 
있었다. 자세한 내용은 기사를 직접 읽어보시길.

\subsection{Cliff Jumping for Amateurs and Other
  Illuminating Stories}

Conference 11/4. Scrum 코치로 활동하고 있는 WIZEWERX의 Mike Sutton이 전한 
동화같은 이야기. 요약하자면 ``동기부여''와 ``신뢰구축''이 성공적인 프로젝트의 
관건이 된다는 것이다.
 
\subsubsection{Courage under Fire}
 
완전히 의욕을 상실한 팀이 있었다. 이 팀은 깐깐한 CTO가 제시한 모종의 solution을
만들어야 한다. 그런데 의욕을 상실했으니 일이 될 리가 없다. Sutton은
팀원 스스로 문제에 대해 토론하고 해결책을 모색하는 미팅을 반나절 동안
진행하도록 했다. 그 결과 그들 스스로 그럴듯한 해결책을 얻게되었다. 그날
저녁 CTO는 개발팀에게 맥주를 샀다.
 
그리고 프로젝트는 예정된 기간보다 조금 앞당겨 마칠 수 
있었다. 원래 계획보다 더 빠방한 기능과 함께.

\subsubsection{Cliff Jumping}
 
미국 금융 회사의 튀니지 사무실에 8명 정도의 개발자들이 모였다. 그들은
모두 처음 만난 사이다.  이 팀을 Sutton이 처음 만났을 때 그들은 Sutton을
매우 따뜻하고 편하게 대해 줬다. 튀지니인들이 좀 다뜻하다고 한다.
 
좋은 사람들이 모였으니 기대를 했겠지? 하지만 첫 번째 sprint가 끝났을 때
그 팀이 이룬 것은 아무것도 없었다. 좀 더 관찰을 해 보니 이 사람들은
서로에 대한 신뢰가 없었다. Sutton은 서로의 이력에 대해 이야기하는
자리도 만들고, 저녁에 회식 자리도 만들었다. 이슬람 국가라 술은 못
마시고 포커, 축구 시청 등의 활동을 하면서 친목을 도모했다.
 
조금씩 나아지고 있었다.
 
어느날 한 팀원이 Sutton에게 해안의 멋진 절벽으로 가서 cliff jumping을
해보자고 제안을 했다. 처음에 Sutton은 싫다고 했다. 위험하다고 생각했기
때문이다.  하지만 라디오에서 들은 ``역경을 함께 헤쳐 나간 사람들''에 대한
이야기가 생각이나 마음을 바꾸기로 했다.
 
팀원들과 함께 찾아간 절벽은 높이가 10미터 정도 되었다. 벼랑 끝에 서서
오만 생각이 다 들었다고 한다. 하지만 두려움을 떨치고 바다로
뛰어들었다.
 
그날 이후 팀웍은 더 욱 단단해 지고.... 일은 잘 끝났다고 한다.
 

\section{Java}

\subsection{When is Garbage Not Garage?}

Conference 11/4. Ari Zilka, Terracotta.
Ehcache를 오픈소스 버전과 enterprise 버전으로 만드는 테라코타사의 제품 설명회.
 
Ehcache를 이용한 caching으로 성능 개선을 할 수 있는데 다가
BigMemory라는 것을 덧 붙여서 JVM의 GC도 안 일어나도록 함으로써 더 높은
성능 향상을 기대할 수 있단다.
BigMemory가 디스크 까지 동원해서 caching 된 object를 붙들고 있음으로써
GC의 overhead를 최소화하는 것이 주요 아이디어라 생각된다.
 
정말 어려운 문제를 푸는데 프로그래밍 언어가 기여할 수 있는 부분이 어느 
정도인지를 생각해 보는 기회가 되었다.
Java가 각광을 받은 이유 중에 하나가 어려운 메모리(자원) 관리로부터 개발자를 
해방시켰다는 점이다. 이를 위해 Java는 포인터를 뺐고, GC를 넣었다. 
하지만 결국 성능 문제를 만나면서 cache를 사용하게 되고, 자원 관리의 몫이 
프로그래밍 언어에서 프로그래머로 넘어오는 상황이 되고 말았다.

\subsection{Many-Core Java}
\label{many core java}

Conference 11/5. Alex Buckley, Java Platform Group at Oracle Corporation.
Oracle 직원이 Java를 소개하러 나온 모습을 보니 뭔가 어색한 기분이
들었다. 
%Oracle이 Google을 겨냥해서 제기한 Java관련 소송 때문에 사악해지고 
%있지 않나 하는 걱정 때문이었을까?

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-lambda}
        \end{center}
    \end{Frame}
    \caption{Many-Core Java}
    \label{lambda}
\end{figure}

Java진영에서는 2009년 말부터 Lambda 프로젝트를 시작했다고 한다. 
2012년으로 예정된 Java SE8에 정식 릴리즈 하는 것이 목표라고 한다.
\texttt{http://openjdk.java.net/projects/lambda/}.
Scala, Clojure 그 외에 내가 모르는 뭔가들이 concurrency에 적합한 언어로
사람들 사이에 인식되어 가고 있는 상황에서 Oracle도 가만 있지는 않았던
것이다.

Filter, sort, map, reduce 등 functional programming에서 cocurrent
programming의 주요 idiom으로 자리 잡아 가고 있는 함수들을 Java도
제공하겠다는 것이다. 그래서 아래와 같은 Java code를 만들 수 있게
하겠다고 했다.
 
Figure \ref{lambda}에서 보다 시피 \#\{ arg -> code\} 형태의 closure를 값으로 
쓸수 있게 하고, filter, map 등은 병렬화 하겠다는 것이 핵심이다. 
map 부분을 보면 type inference도 해 준다는 것을 알 수 있다.
 
여기까지는 좋았다. 하지만 역시 Java는 ``Kingdom of Noun''의 왕이었다.
 
Lambda abstraction을 쓰려면 이른바 SAM(single abstract method)
인터페이스를 정의해야 한단다.  SAM의 예로는 Runnable, Callable,
Comparator, ActionListener 등이 있다. Closure를 쓰려면 type 별로
메소드가 하나인 인터페이스를 정의해야 하는 것이다.
 
여기서부터 사람들이 술렁거렸다. Buckley는 수백만 개발자를 거느린
Java로서는 기존 코드와의 호환성을 고려하지 않을 수가 없단다. 나로서는
매우 아쉽다. Oracle도 심사 숙고해서 내린 결정일라 믿는 수 밖에. Java가
마음에 안 들면 Scala나 Clojure를 쓰면 되고.

\subsection{Clojure-Java Interop: A Better Java than Java}
Conference 11/3.
\textit{Programming Clojure}\cite{halloway}의 저자 Stuart Halloway가 발표를 
했다. 내가 QCon에서 본 발표자 중에 가장 명쾌하게 발표를했다고 생각한다. 
Struart가 쓴 책 마저 조만간에 살 것같은 느낌이 든다.
 
\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-clojure-java}
        \end{center}
    \end{Frame}
    \caption{Clojure Java Interop}
    \label{clojure java}
\end{figure}

% Clojure가 JVM에서 돌아가는 언어로서는 Java 보다 낫다고 주장. Java 보다
% 나중에 나왔으니 당연히 그래야죠.
 
\subsection{Perception and Action: an Introduction to Clojure's Time Model}

Conference 11/5. 다시 멋진 Stuart Halloway.
 
% 이번 QCon 발표자 중 가장 명쾌한 스타일의 발표를 한 사람으로
% 생각됨. \textit{Programming Clojure}의 저자이기도 한데 이 책을 사고 싶어
% 졌다.
 
Functional programming의 특징 중 하나가 value-oriented라는
것이다. Imperative language(C, Java, ...)의 variable은 value를 assign
하면 의미하는 value가 바뀐다. Functional programming은 변하지 않는
value를 다룬다. 어떻게 다루냐 하면, value에 function을 적용해서 새로운
value를 만들어 내는 방식으로 다룬다.
 
Clojure가 다루는 데이터도 모두  immutable value이다. 
 
데이터가 변하지 않는 다는 것은 concurrenct programming을 매우 쉽게 할
수 있는 조건이 된다.
 
Clojure 웹 사이트의 다음 두 글을 한 번 보는 것도 좋겠다:  ``On state and
identity'', ``Concurrent programming''.
 
\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-clojure-concurrent}
        \end{center}
    \end{Frame}
    \caption{Concurrent Programming in Clojure}
    \label{clojure concurrent}
\end{figure}

\section{Practices}

\subsection{Continuous Delivery}
Tutorial 11/2.
Martin Fowler, Jez Humble, Tom Sulston 세 명이 합동 진행한 튜토리얼.
% 셋이서 각본을 잘 준비한 건 아닌 것 같았다.
%
% 이 분들의 머리 속에는 여러가지 덕목이 기본으로 깔려있겠지만 그 중 다음
% 이야기를 하나 건졌다.

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-continuous-delivery}
        \end{center}
    \end{Frame}
    \caption{Continuous Delivery 1/2}
    \label{Continuous Delivery 1}
\end{figure}

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=2]{slide-continuous-delivery}
        \end{center}
    \end{Frame}
    \caption{Continuous Delivery 2/2}
    \label{Continuous Delivery 2}
\end{figure}

``Continuous integration''이 개발팀 내의 merge practice를 개선하는 것에
중점을 두고 있다면, ``continuous delivery''\cite{hufa10}는 
production environment로 좀더 자주 제품을 릴리즈할 수 있는 방법을 찾는데 
중점을 두고 있다.

\begin{quote}
``If it hurts, do it more often, and bring the pain forward.''  
\end{quote}

변경(code, library, configuration, environemt)에 대한 빠른 feedback과
human error를 줄이기 위해 자동화를 엄청나게 강조했다. 튜토리얼에서 Fowler는
소리를 지르며 울분을 토하듯이 자동화를 이야기 했다. 덕분에 나로서는 
제대로 못 알아 듣는 부분이 많았다.

Production environment에 자동으로 deploy하는 데 참고할 만한 방법들도 소개를
했다: Feature toggle, blue-green deployments, canary release, dark launching,
rollback, DB deployment, ...

좀 무리한 요약일 수도 있으나 continuous delivery는 다음과 같이 요약할 수도 
있겠다:
\[
    \mbrm{Continuous Delivery} = \mbrm{Continuous Integration} + \mbrm{Automatic Acceptance Test} + \mbrm{Automatic Deployment}
\]

\subsection{Developing Products at the Speed and Scale of Google}

Conference 11/3.
발표자는 Ashish Kumar. Google의 Engineering Tools 팀의 매니저이다.
원래 다른 사람의 발표가 잡혀있었는데 발표자의 집안 일로인해 프로그램이 
변경되었다. 결과적으로 프로그램 변경은 완전 뜻밖의 선물이 되었다. 
내가 회사에서 하고있는 일이나 관심분야와 싱크로율이 매우 높은 세션이었다.

Engineering Tools 팀의 인원은 100명 정도라고한다. 
구글의 개발자가 5000명이 넘고, 진행되는 과제는
2000개 정도인데 100명이 90\%의 과제를 지원하고 있다고 했다. 
개발자 50명 당 engineering tool 인원이 1명인 셈이다.

% Engineering tools팀이 하는 일이 LCD TV 연구소에서 했던 SVN, CIS 인프라
% 구축과 매우 흡사해서 듣는 내내 흥미로웠음.
 
이 팀의 미션은 ``아이디어를 제품으로 만드는 과정을 가속시키는
것''이라고 했는데 무척 마음에 와 닿았다.

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-google}
        \end{center}
    \end{Frame}
    \caption{Deveoping Products at the Speed and Scale of Google}
    \label{google}
\end{figure}
 
이야기를 다 듣고 나니 결국 우리와 비슷한 일을 하지만 차원이 좀 다르다는
느낌을 받았다. 우리는 check out이 느리면 속도가 빠른 소트리지를 사는
정도인데 구글은 파일시스템을 바꿔 버리고(FUSE), 그것 때문에 빌드가 곤란해지면
그 문제를 해결하는 빌드 툴을 만들었다. 빌드에 시간이 많이 걸리면
컴파일러를 개선한다. 그래도 성에 차지 않으면 하드웨어를 증설한다. 그
하드웨어도 cache, cloud 기술을 이용해 알뜰하게 사용한다. 그리고
구글에서 테스트를 손으로 하고 있으면 원시인 취급을 받을 것이다.

\subsection{Lessons Learned to Lessons Productized at
  Microsoft Developer Division}

Conference 11/5. Tim Wagner, Visual Studio Platform Dev Manager at Microsoft.
Visual Studio 2010(VS2010)을 만들면서 있었던 이런 저런 이야기를
했다. LG전자도 하나의 제품을 만든 다음에 이런 발표를 한 번씩 하면 어떨까
하는 생각이 들었다.
 
\begin{itemize}
\item Population diversity
    \begin{itemize}
    \item 자기 개밥을 먹어봐야한다. 근데 다른 사람도 먹여야 한다. 가능하면 많이.
    \item VS2010은 4000명 정도에게 먹였다고 함.
    \end{itemize}
\item Big rock \& agile
    \begin{itemize}
    \item 개발자가 3000명 정도 됨. 잘못 들은 것 같지 않음.
    \item 전체 portfolio 관리와 기능 별 소규모 팀의 agile 개발 사이의 조화
        \begin{itemize}
        \item unit test, path analysis
        \item detect code ``repeat'' \& fix suggestion
        \item mocking frameworks
        \item statistical analysis of bugs and bug fixes
        \end{itemize}
    \end{itemize}
\item 제품 별 branch에서 큰 기능 단위의 branch로 바꿈.  기능 별 팀 구조라서 그런 듯.
\item Internal code motion dashboard 운영
    \begin{itemize}
    \item 결함, 빌드, 릴리즈 등 정보 파악
    \end{itemize}
\item Customer feedback
    \begin{itemize}
    \item Watson: functionality
    \item PerfWatsons: responsiveness
    \item Email
    \item SQM(software quality management)
    \end{itemize}
\item Architecture
\item Testing
    \begin{itemize}
    \item Memory analysis over time
    \item Memory leak
    \item GC problem
    \end{itemize}
\end{itemize}

\subsection{Hot Swapping Your Engine at 30,000 Feet}

Conference 11/4. Rod Barlow, \texttt{http://shopzilla.com}.
꽤 젊어 보이는 친구가 말은 어찌나 잠오게 하는지...
 
Shopzilla와 Bizrate라는 두 쇼핑 사이트를 각각 1999년과 2004년에 오픈한
후 이용자가 늘면서 페이지 하나 보는데 7초가 걸릴 지경이 되었다고 한다.
개발자들은 이 문제르 개선하기 위해 architecture부터 새롭게 설계를 하기로 했다.
여기까지는 상식적이다.

새로운 architecture를 구현하고 운영 사이트에 적용하는 것은 ''Agile Spirit''에
입각해서 사이트를 조금씩 수정하느 형태로 진행했다고 한다. 발표 제목처럼
비행기가 날고 있는 상태에서 엔진을 바꿔기로 한 것이다.
 
\begin{quote}
Plan: a service-oriented site architecture (resilient to
sub-system failures), and a RESTful layer on top of our search
infrastructure
\end{quote}

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-swapping-engine}
        \end{center}
    \end{Frame}
    \caption{Hot Swapping Your Engine at 30,000 Feet}
    \label{swapping engine}
\end{figure}

\subsection{Inter-Disciplinary Design in a Large
  Organization Context}

Conference 11/5. Robert Sedor, Lead Architect, Pitney Bowes Engineering.

편지와 봉투를 인쇄해서 배달해 주는 서비스를 제공하는 솔루션을 만드는
프로젝트를 어떻게 이끌고 있는 지를 이야기 했다.
우리 말로 하면 기구, 회로, 소프트웨어 개발자가 모여서 하는
과제이다. 소프트웨어 개발자도 embedded software, web software, desktop
software 등 다양하게 구성되어 있다고 한다.
 
발표 내용을 한 마디로 요약하면 ``commnunication을 잘 해야 이런 과제를 할 수 
있다.''이다.
 
그 외에 몇 가지 언급한 사항은 다음과 같다.
\begin{itemize}
\item 설계는 commnication이 쉽도록 만들어야 한다.
    \begin{itemize}
    \item 확장성이 있도록 설계해야 한다.
    \item MVC 모델이 협업에 좋더라
    \end{itemize}
\item Building \& Versioning 을 잘 해야 한다.
    \begin{itemize}
    \item 모든 것을 자동화 해야 한다.
    \item 테스트 자동화에 Squish라는 도구를 사용함
    \end{itemize}
\item 당장하는 과제와 상관이 없더라도 개발자가 관심을 갖는 분야에 시간을 투자할 수 있도록 해야 한다.
\end{itemize}
 
\subsection{QCon Camp - Unit Test}

Conference 11/4. 저녁에 구글 리셉션이 있었다. 조잡한 기념품과 미국인들은
이따위 음식만 먹고 살리가 없다는 생각이 들게 하는 부페가 제공되었다.
 
구글 리셉션 후에는 QCon 참가자들이 자유롭게 조직한 토픽과 일정에 따라
모임을 갖는 시간인 QCon Camp가 열렸다. 8개 정도의 모임이 만들어 졌는데
나는 unit test 모임에 참여 하기로 했다.
 
개인적으로 unit test를 제대로 해 본적이 없어 미국 개발자들은 어떤
생각을 갖고 있는 지, 어떻게 unit test를 하는 지 궁금했다.
 
% 결론적으로 한 시간 동안 진행된 미팅 동안 한 마디도 하지 못했다. 쪽
% 팔려서. 차마 내 입으로 ``LG전자 소프트웨어 개발자들은 자기가 만든 코드를 테스트
% 하지 않습니다.''라고 할 수가 없었다. 그렇다고 거짓말도 못하겠고.
 
한 10명 정도 모여 둘러 앉았는데 다들 평소에 고민하고 실행한 경험에서
우러나오는 얘기들을 쏟아 냈다.
 
모인 사람들이 로 Java 개발자들이었는지 unit test의 unit은 하나의
클래스에 대응 되는 것으로 이야기들을 했다. 하나의 unit을 테스트 할 때
필요한 다른 클래스들은 모두 mokc-up으로 만 들어야 한다는 얘기, unit
test는 설계를 검증하는 거라는 얘기 등. 
(그런데 이게 어디 책같은 데 나오는 얘긴가?)
 
어쨋거나 이야기는 
\begin{itemize}
\item function test, integration test, acceptance test로 뻗어 나가는 가 싶더니 
\item JDBC를 쓰는데 SQL parser는  mock-up으로 해야 하느냐 아니냐 하기도 하고 
\item mock-up framework은 뭐가 좋다 둥 
\item 우리는 자바 스크립트나 html도 unit test를 한다는 둥
\item 테스트를 자동으로 돌리기 위해 Amazon의 EC2 cloud 이용한다면서 
\end{itemize}
시간 제한이 없었다면 밤샐 기세로 이야기를 쏟아냈다. 

이러는 동안에 나는
우리 개발자들은 왜 자기 코드에 대한 테스트를 하지 않을까라는 생각에
빠지게 되었다. 나름 내린 결론은 LG전자는 HW를 만드는 기업에서 출발했기
때문이다라는 것이다.
HW를 시험하는 데 익숙했던 방식을 아직 버리지 못했다기 보다 소프트웨어를
시험하는데 필요한 것들이 아직 채워지지 않았다는 뜻이다. 이렇게 된
이유는 소프트웨어를 시험하는데 필요한 것이 비어있다는 것을 아직 우리 스스로가
몸으로 느끼지 않기 때문이 아닐까?
 
% 소프트웨어가 우리의 육안에 보이도록 해야만 소프트웨어에 필요한 시험도 채워질 
% 것 같다.

\section{Architecture}

\subsection{REST from Scratch}

Tutorial 11/1. Caelum의 Guilherme Silveira의 튜토리얼.

소프트웨어 개발 infrastructure를 구축하다보면 어쩔수 없이 웹 프로그래밍을 
하게 되는 경우가 많다. 게다가 세상이 이미 웹이라는 거대한 망으로 묶여 있기도 
해서 WWW 관련 기술에는 관심을 안 가질 수 없다고 생각한다. Architecture적으로도
WWW에는 배우고 깊이 생각해볼 만한 토픽도 많고.

REST(Representational State Transfer)에 대해서는 다 알고 왔을 거라고 전제를 
하더니만 제목과는 다르게 막바로 Restfulie\cite{restfulie}라는 REST 
framework에 대한 설명에 돌입했다. 어쩔 수 없이 wikipedia를 참고했다. 
REST는 ``WWW과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 
형식(architectural style)''\footnote{\url{http://ko.wikipedia.org/wiki/REST}}이라고 한다.

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-rest}
        \end{center}
    \end{Frame}
    \caption{REST from Scratch}
    \label{REST}
\end{figure}

% 항공 예약 사이트(TRIP), 신용카드 결재 사이트(PAY), 캘린더 사이트(CAL)가 
% 있다고 하자. 각 사이트에서 여행
% 예약은 TICKET에서 한다. 여정, 항공사 등을 다 선택한 후 예약 페이지에 있는 
% 예약 버튼을 눌렀다고 하자. `예약'이 하나 TICKET에 만들어 진것이다. 
% 
% 발표자 Guilherme Silveira의 여자 친구가 브라질의 한국 교포라고 한다.
% 상파울루에서 서울로 가는 비행기 예약하는 경우를 예로 들면서 튜토리얼을 
% 진행하기도 했고, 슬라이드에 한국에서 찍은 사진을 사용하기도 했다.
% 프리젠테이션에 사용한 맥북의 언어 설정도 한국어로 해 놨었다.

% 꽤 스마트해 보여서 따로 만나 얘기를 좀 나눴다. 브라질 상파울루 지역에서는 
% 개발자들이 파이선에서 루비로 옮겨 가는 중이라고 한다. 같이 얘기하던 미국 친구도
% 맞장구를 쳤다.

% 당연히 일은
% 재미있어야 하지만 자기만 재미있으면 안 될 것이다. 이 아저씨 회사가 하는
% 일이 교육이라서 신 기술을 좋아하는 건 아니겠지?

\subsection{Dataflow Programming: a Scalable
  Data-Centric Approach to Parallelism}

Conference 11/3. 발표자는 Prevasive사의 Jim Falgout.
 
Java로 dataflow programming을 할 수 있는 DataRush라는 솔루션을 설명했다.
Multi-core+I/O 또는 multi-node환경에 적용할 수 있다고 한다.
 
DataRush에서 dataflow는 edge는 데이터 queue, 노드는 operator인 DAG로 표현된다.
Erlang이나 Scala의 actor패턴과 같은 프로그래밍 API가 제공된다고 한다.
Open cloud consortium의 벤치 마킹 결과 DataRush가 Hadoop보다 성능이 좋다고도
하고, 대용량 데이터를 처리하는 금융업계에서 needs가 많다고 했다.
 
% Embedded system에서도 multi-core + Java를 도입하고 있으므로 이런
% 환경에서도 활용할 날도 오지 않겠냐는 이야기를 했다.
 
\subsection{Consistency Models in New Generation Databases}
Conference 11/4. MongoDB를 만드는 10gen.com의 Roger Bodamer의 발표.
 
NoSQL(MongoDB) 계열의 DB를 master와 복수의 slave로 구축하는 경우에도
나름 data consistency를 유지하는 방법이 있다는 이야기이다.
 
\begin{itemize}
\item Eventually consistent
    \begin{itemize}
    \item ex) DNS, memcaced, async replication, ...
    \end{itemize}
\item RYOW(read your own write)
\end{itemize}
 
다른 NoSQL 계통의 DB도 될 것 같은데 MongoDB는 sharding이라는 기능이
있어 shared key를 하나 지정하면 data를 여러 서버에 나눠 저장할 수
있다고 한다.

\subsection{Being Elastic - Evolving Programming for the Cloud}

Keynote 11/4. eBay의 Randy Shoup의 키노트.
Figure \ref{cloud}에 있는 cloud 환경에서 실행되는 소프트웨어를 개발할 때
고려해야할 사항들의 개요를 이야기 했다.

% Throughput은 `리소스'와 `커뮤니케이션'에 의해 결정된다는 Neil Gunter의
% ``Universal Law of Computational Scalability''이론을 인용함.

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-cloud}
        \end{center}
    \end{Frame}
    \caption{Being Elastic - Evolving Programming for the Cloud}
    \label{cloud}
\end{figure}

Cloud 기술을 이용해 사내 소프트웨어 개발 환경을 만들어 보는 것도 재미있을 
것이라 생각된다.

\subsection{Abstractions at Scale, Our Experience at Twitter}

Conference 11/5. Marius Eriksen, Twitter.
 
결론 부터 이야기 하자면 아무 내용이 없는 발표였다. 유일하게 red card를
준 세션.
 
Twitter, Google 이런 곳과 관련된 세션은 항상 빈자리가 없었다. 이번
세션도 마찬가지 여서 난 맨 끝자리에 겨우 앉을 수 있었다. 서서 듣는
사람, 늦게 와서 그냥 돌아간 사람 등도 있었다.
 
정말 충격적으로 한시간 내내 Scala, database, memory, CPU, GC, VM,
MapReduce, Google App Engine, Rails, Django, BigTable, LWT, .... 이런
것들의 개요만 나열했다.
 
20대로 보이던데 자기가 `아는 걸' 보여 주고 싶은 생각에 빠져 있어서
였을까? 자기가 `한 일'을 설명하면 더 좋았을 텐데...
 
중간에 빠져 나가는 사람들이 속출했는데 난 혹시나 하고 계속 있었다. 

\section{기타}

소프트웨어 개발 practice나 Java 관련 세션에 비중을 두고 참석할 세션을
골랐다.

\subsection{The Problem with the Browser}

Conference 11/4. Colling Jackson, \texttt{http://websec.sv.cms.edu}.
 
사내 용으로 몇 가지 웹 시스템을 만들면서 겪은 문제 세가지를 꼽으라면 다음 
세가지를 들 수 있다:
\begin{itemize}
\item 브라우저에 따라 동작 여부가 다른 경우
\item 한글이 제대로 안 보이는 경우
\item MySQL 성능이 저하되는 경우
\end{itemize}
 
트랙은 웹 보안이었지만 제목을 보고 브라우저 별 특성을 좀 언급할 거라 생각했다.
하지만 기대와는 다른 내용이었다.
 
\begin{itemize}
\item 인증을 어떻게 할 것인가: URL 기반, 쿠키 기반, HTTP auth, ...
\item cross site request forgery 대응책
    \begin{itemize}
    \item secret hidden value: rails
    \item referer validation: facebook
    \item custom header: gmail
    \end{itemize}
\item Network  attack은 https로 
\item SSL rebinding
\item browserscope.org 
\end{itemize}
 
\subsection{Software Design in the 21st Century}

Keynote 11/5. Martin Fowler의 키노트.
 
21세기가 시작된지도 10년이 넘었지만(2000년부터 21세기라면) ``21세기의
디자인''은 아직 오지 않은 세상의 디자인에 대한 이야기일 거라는 생각을
들게 했다.
 
세가지 토픽을 다뤘는데 다음과 같다.
 
\subsubsection{DSL(Domain Specific Language)}
 
% TODO: 내용도 보강하고, 위치도 옮기도...

우리는 이미 여러가지 DSL을 사용하고 있다며
예로는 SQL, CSS, HQL, Regex, ... 등을 예로 들었다.

DSL은 생산성을 향상시킨다고 한다.
어떤 기능을 state machine으로 정의할 수 있고, state machine을 DSL로
정의하면 매우 쉽게 기능을 구현할 수 있다는 예를 들었다.

\begin{figure}[t]
    \begin{Frame}
        \begin{center}
        \pgfimage[width=.8\textwidth,page=1]{slide-dsl}
        \end{center}
    \end{Frame}
    \caption{Dmain Specific Language}
    \label{dsl}
\end{figure}
 
\textit{Domain Specific Languages}\cite{fowler}라는 Fowler가 쓴 책 선전도 함.
 
소프트웨어를 잘 만들기 위해서는 complexity를 abstraction이라는 도구로
제어를 할 수 있어야 한다는 SICP의 이야기 처럼 DSL이 좋은 소프트웨어를
만드는 한 방법이 분명히 될 수 있을 것이다. 그리고 Figure \ref{dls}에서 
언급했지만 우리 선배들은 매크로라는 것을 이미 우리들에게 물려 주었다.
 
구더기 무서워서 장 못담그냐고 할 수 있지만 한 마디 덪붙이자. DSL은 분명
어떤 부분의 complexity를 낮춰 주지만 DSL 자체는 (complexity가 높을 수도
있고 아닐 수도 있지만) 관리를 해야할 대상이 된다고 생각한다.
 
\subsubsection{Continuous Integration \& Delivery}
 
튜토리얼 때 했던 이야기를 간단하게 요약함. 
 
Fowler의 integration은 main trunk에 소스를 모으는 것을 의미한다는 점을
다시 확인했다. 물론 text merge는 도구가 다 해주니 문제가 아니고,
semantic merge가 제대로 되었는 지를 확인하기 위해 build, test,
analysis 등을 해야 한단다.
 
그리고 integration 즉, merge는 최소한 하루에 한 번은 해야 하는 것이
자기의 규칙이라고 함.
 
\subsubsection{Event Sourcing}
 
Fowler의 홈페이지에 소개되어 있음.
\url{http://martinfowler.com/eaaDev/EventSourcing.html}.
 
키노트 때 노트에 기록도 하고 대강 이해했다고 생각을 했다. 막상 여기에
정리하려다 보니 Event Sourcing이 뭐에 도움이 되는 지가 명확하지 않아
구글링을 좀 했다.
 
결과는 좀 나로서는 좀 거북했다. Event Sourcing과 같이 나타나는 단어로
CQRS(command and query repsponsibility segregation), DDD(domain-driven
design)가 등장했다. 이중 CQRS는 Fowler가 언급하기도 한 것이다. 이런
류의 단어에 대한 선입견 같은 것이 좀 있어서 마음이 거시기 한
듯. 궁금하신 분들은 직접 찾아 보시라.
 
Event Sourcing은 내가 이해한 바로는 database의 로그와 같은 것을
어플리케이션에 장착하자는 거다. 어플리케이션의 상태 변경을 event들의
sequence로 저장하자는 것이다. 이렇게 하면 나중에 database의 redo, undo
같은 것을 어플리케이션에 대해서도 할 수 있다는 것이다.
 
구글링의 결과지만... Event Sourcing은 enterprise application
architecture를 위한 디자인 패턴이이라고 한다. 따라서 앞의 로그 파일
같은 거라는 얘기는 정확한 것은 아니다.
 
이게 왜 좋으냐? audit trail을 할 수 있어서 좋단다. 이게 처음으로 언급된
좋은 점이어서 꽤 놀랐다. 그 다음은 상태 변경을 재현 할 수 있어
debugging에 도움이 된다고 한다. 임의의 event들을 만들면 시험에도 쓸 수
있을 것으로 생각된다.





% \section{정리}
% 
% 2010년 11월 6일 새별 2시 8분.
% 샌프란시스코에서

\bibliographystyle{plain}
\bibliography{references}

\end{document}
